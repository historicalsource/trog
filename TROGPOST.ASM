	.MLIB	"TROGMACS.LIB"
	.FILE	'TROGPOST.ASM'
	.TITLE	" <<< T R O G  -- POST AND MOVE ROUTINES >>>"
	.WIDTH	132
	.OPTION	B,D,L,T
	.MNOLIST

**************************************************************************
*								         *
* 	     COPYRIGHT (C) 1990 MIDWAY MANUFACTURING COMPANY,		 *
* 	      MANUFACTURERS OF BALLY/MIDWAY AMUSEMENT GAMES.		 *
* 		         ALL RIGHTS RESERVED.				 *
*								         *
**************************************************************************

*	GET THE SYSTEM STUFF
	.INCLUDE	"MPROCEQU.ASM"	;MPROC equates
	.INCLUDE	"DISPEQU.ASM"	;Display processor equates
	.INCLUDE	"GSPINC.ASM"	;GSP assembler equates
	.INCLUDE	"SYSINC.ASM"	;Zunit system equates
	.INCLUDE	"TROGEQU.ASM"
	.INCLUDE	"IMGTBL.GLO"

	.DEF	TOMOVE, CONSMOVE, GETMOVE, PJOY
	.DEF	GETCMOVE, GETEMOVE, FINDCMOVE, BOUNDRY_CHECK, TWO_MOVES
	.DEF	FINDMOVE, DSRCH_CLR, GETAMOVE, FIND_CLOSE_CPNT, FINDAMOVE
	.DEF	FIND_CLOSE_MPNT, ONE_MOVE, FREE_MOVE_EGG, FIND_CLOSE_EPNT
	.DEF	FIND_CMOVE_X, FIND_CMOVE_Y, COUNT_FREE_CMOVES
	.DEF	FIND_FARTHEST_CPNT

	.REF	GPLAYD, DINO_PNT_TST, COCKTAIL
	.REF	OBJ_WHOLE_CENT

MAXDINOS	EQU	8
	.BSS	DINO_LOC_LIST,((MAXDINOS+1)*32)	; DINO LOCATION LIST
	.BSS	FAR_LOCS,(NCMOVES*32)	; LOCATIONS FOR FIND FARTHEST
	.BSS	FAR_NUM,16		; NUMBER OF FARTHEST ENTRIES

	.text

**************************************************************************
*								         *
* 		PLAYER JOYSTICK HANDLING PROCESSES			 *
* 									 *
* *A13(PROCID) = 0001 0PPP DDSS SSSS					 *
* 	WHERE:								 *
* 		PPP = PLAYER #						 *
* 		DD =  DIRECTION						 *
* 		SS SSSS = SWITCH #					 *
*								         *
**************************************************************************
PJOY
	MOVE	@GAME_STATE,A0,W
	CMPI	INPLAY,A0
	JRNE	PJOYDI			;BR = NO SWITCH HITS WHILE NOT INPLAY

	MOVE	*A13(PROCID),A9,W
	MOVE	A9,A0			;GET PLAYER DATA AREA
	SLL	21,A0
	SRL	29,A0			;BASED ON THIRD NIBBLE OF PID
	DEC	A0	

	MOVE	@COCKTAIL,A1,W		;ARE WE DEALING WITH A COCKTAIL TABLE?
	JRZ	PJOY_NORM		;BR = NO

	CMPI	1,A0			;IS THIS PLAYER 1 OR 2?
	JRHI	PJOY_NORM		;BR = NO
	JRNE	PJOY_P1

	MOVI	P2_COCKTAIL_XLATION,A2
	JRUC	PJOY_XLATE
PJOY_P1
	MOVI	P1_COCKTAIL_XLATION,A2
PJOY_XLATE
	MOVE	A9,A1
	SLL	24,A1
	SRL	30,A1			;ISOLATE DIRECTION
	SLL	3,A1			;MAKE IT AN INDEX
	ADD	A1,A2
	MOVB	*A2,A1			;XLATE TO A NEW DIRECTION
	MOVE	A1,A10			;NEED THIS FOR LATER
	SLL	6,A1
	OR	A1,A9			;STORE HERE IN CASE SOME WANTS IT			
	JRUC	PJOY_SKIP_DIR

PJOY_NORM
	MOVE	A9,A10
	SLL	24,A10
	SRL	30,A10			;GET STICK DIRECTION

PJOY_SKIP_DIR
	CALLA	GPLAYD
	INCM	*A2(PJOYESC),W		;FLAG THE STICK ACTION

	MOVE	*A2(PTRUEJOY),A3,W
	BTST	A10,A3			;ARE WE CURRENTLY GOING IN THIS DIRECTION
	JRNE	PJOYDI			;BR = YES, THEN BUTT OUT!

	CLR	A4			;ONLY ONE STICK DIRECTION AT A TIME
	BSET	A10,A4
	MOVE	A4,*A2(PJOYSTCK),W	;SET CURRENT JOYSTICK
	OR	A4,A3
	MOVE	A3,*A2(PTRUEJOY),W	;KEEP RECORD OF THIS ACTION

	MOVE	A9,A11
	SLL	26,A11
	SRL	26,A11			;ISOLATE SWITCH # FOR LATER REF.
	MOVE	A2,A8			;STORE PLAYER DATA HERE

	SLEEP	1
PJOY_WATCH_LP
	CMPI	31,A11			;IN THE LOW SWITCH REGISTER?
	JRLS	PJOY_LOWSB		;BR = YES
	MOVE	@SWITCH2,A0,L
	MOVE	A11,A1
	SUBK	32,A1
	BTST	A1,A0			;STILL HOLDING IN THIS DIRECTION?
	JREQ	PJOY_REP_SLP		;BR = YES
	JRUC	PJOYX
PJOY_LOWSB:
	MOVE	@SWITCH,A0,L
	BTST	A11,A0			;STILL HOLDING IN THIS DIRECTION?
	JRNE	PJOYX			;BR = NO
PJOY_REP_SLP:
	SLOOP	1,PJOY_WATCH_LP
PJOYX
	SLEEP	2			;BOUNCE PROTECT

	MOVE	A8,A2
	MOVE	*A2(PTRUEJOY),A3,W
	BCLR	A10,A3
	MOVE	A3,*A2(PTRUEJOY),W	;CLEAR THE HAPPENINGS

	MOVE	*A2(PJOYSTCK),A4,W	;EXECUTING THIS DIRECTION?
	BTST	A10,A4			
	JREQ	PJOY_RESET_AND_DIE	;BR = NO, THEN DON'T REPROCESS

	LMO	A3,A4			;ANY OTHER STICK BITS TO BE PROCESSED?
	JRZ	PJOY_STICK_CLEAR	;BR = NO
	SLL	27,A4
	SRA	27,A4
	NOT	A4
	CLR	A3
	BSET	A4,A3			;ONE OF THE REMAINING STICK BITS CURRENT
PJOY_STICK_CLEAR
	MOVE	A3,*A2(PJOYSTCK),W

*
*A11 = SWITCH NUMBER WE ARE CURRENTLY CONCERNED WITH
PJOY_RESET_AND_DIE:
	CLR	A0
	CMPI	31,A11			;ARE WE IN THE SECOND SWITCH REG?
	JRLS	PJOY_RSW		;BR = NO
	SUBK	32,A11
	BSET	A11,A0
	ORM	A0,@SW2TEMP1,L
	ORM	A0,@SW2TEMP2,L		;CLEAR THE SWITCH DEBOUNCE TO RE-TRIGGER
	JRUC	PJOYDI
PJOY_RSW:
	BSET	A11,A0
	ORM	A0,@SWTEMP1,L
	ORM	A0,@SWTEMP2,L		;CLEAR THE SWITCH 2 DEBOUNCE TO RE-TRIGGER
PJOYDI
	DIE
*
*A9 = JOYSTICK SWITCH PROCESS I.D.
PJOY_SWITCH_RESET:
	MOVE	A9,A11
	SLL	26,A11
	SRL	26,A11			;ISOLATE SWITCH #
    	JRUC	PJOY_RESET_AND_DIE

*
*MIDWAY COCKTAIL TRANSLATION TABLE
*
P1_COCKTAIL_XLATION
	.BYTE	RIGHT,LEFT,UP,DOWN
P2_COCKTAIL_XLATION
	.BYTE	LEFT,RIGHT,DOWN,UP
	.EVEN

**************************************************************************
*                                                                        *
* GETPOST - GET A POST TABLE ENTRY					 *
* A0 = POST #								 *
* RETURNS								 *
* A0 = PTR TO POST TABLE ENTRY						 *
*                                                                        *
**************************************************************************
GETPOST
	PUSH	A1
	MOVI	POSTSIZE,A1
	MPYU	A0,A1
	MOVE	@POSTMAP,A0,L
	ADD	A1,A0
	PULL	A1
	RETS

**************************************************************************
*                                                                        *
* BOXDIMEN - CALCULATE A TYPICAL BOX SIZE X,Y IN THIS GRID		 *
* 		THEY WILL BE STORED IN THE GLOBAL VARIABLE BOXDIM.	 *
*                                                                        *
**************************************************************************
BOXDIMEN
	MMTM	SP,A0,A1,A2
	CLR	A0
	CALLR	GETPOST
	MOVE	*A0(POSTPOS),A1,L
	MOVE	*A0(POSTREL),A0,L
	MOVE	A0,A3
	SLL	16,A0
	SRL	24,A0
	CALLR	GETPOST
	MOVE	*A0(POSTPOS),A2,L
	MOVE	A3,A0
	SRL	24,A0
	CALLR	GETPOST
	MOVE	*A0(POSTPOS),A0,L
	SUBXY	A1,A2
	SUBXY	A1,A0
	MOVY	A2,A0
	MOVE	A0,@BOXDIM,L
	MMFM	SP,A0,A1,A2
	RETS
	
**************************************************************************
*                                                                        *
* CONSMOVE - CONSTRUCT THE MOVE TABLE					 *
*                                                                        *
**************************************************************************
CONSMOVE
	MMTM	SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14
	MMTM	SP,B0,B1,B2,B3,B4,B5

	CALLR	INITMOVE	;FIRST INITIALIZE THE MOVE MAP
	CALLR	INITCMOVE	;INITIALIZE THE CENTER POINT MAP
	CALLR	INITAMOVE	;INITIALIZE THE AUXILARY POINT MAP
	CALLR	INITEMOVE	;INITIALIZE THE EXIT POINT MAP
	CALLR	BOXDIMEN	;CALCULATE TYPICAL BOX DIMENSIONS

	MOVE	@POSTMAP,A2,L	;GET THE POST MAP
	CLR	A4		;THIS IS THE INDEX COUNTER
	MOVE	*A2(POSTPOS),A5,L
CONSLP
	MOVE	A5,A3
	CALLR	ADDMOVE		;CALL THIS POST MOVE POINT
	JRZ	CONSMX		;NO MOVE POINTS LEFT

*ADD THESE TWO LINES FOR DIFFERENT MOVE PATTERN
****	MOVI	THRU,A6
****	MOVB	A6,*A1(MOVETYPE) ;AH A THROUGH MOVE

	MMTM	SP,A0,A1	;STACK THE RESULTS
	MOVE	*A2(POSTREL),A6,L	;GET THE POST RELATIONSHIP
	MOVE	A6,A0
	SRL	24,A0
	CALLR	MOVEPNT			;MOVE POINT TO THE RIGHT
	MOVE	A0,A7
	MOVE	A1,A8
	MOVE	A6,A0
	SLL	8,A0
	SRL	24,A0
	CALLR	MOVEPNT			;MOVE POINT TO THE LEFT		
	MOVE	A0,A9
	MOVE	A1,A10
	MOVE	A6,A0
	SLL	16,A0
	SRL	24,A0
	CALLR	MOVEPNT			;MOVE POINT DOWN
	MOVE	A0,A11
	MOVE	A1,A12
	MOVE	A6,A0	
	SLL	24,A0
	SRL	24,A0
	CALLR	MOVEPNT			;MOVE POINT UP
	MOVE	A0,A13
	MOVE	A1,A14

*CALCULATE CORNER POSITIONS
	MOVE	A14,A14
	JRZ	CONSNTOP
	MOVE	*A14(MOVEPOS),A0,L	
	JRUC	CONSTOP
CONSNTOP
	CLR	A0
	NOT	A0
CONSTOP
	MOVE	A8,A8
	JRZ	CONSNRT
	MOVE	*A8(MOVEPOS),A5,W
	JRUC	CONSRT
CONSNRT
	CLR	A5
	NOT	A5
CONSRT	
	MOVY	A0,A5			;A5 = [TOP Y,RIGHT X]	
	MOVE	A12,A12
	JRZ	CONSNBOT
	MOVE	*A12(MOVEPOS),A0,L
	JRUC	CONSBOT
CONSNBOT
	CLR	A0
	NOT	A0
CONSBOT
	MOVE	A10,A10
	JRZ	CONSNLF
	MOVE	*A10(MOVEPOS),A6,W
	JRUC	CONSLF
CONSNLF
	CLR	A6
	NOT	A6
CONSLF
	MOVY	A0,A6			;A6 = [BOT Y,LEFT X]	
	MOVE	A5,A3

	MOVE	*A2(POSTREL),A0,L
	SRL	24,A0			
	CMP	A4,A0
	JREQ	CONSURC_OK
	MOVE	A0,A1			;CHECK FOR THE EXISTENCE OF		
	CALLR	GETPOST			;U/R DIAGONAL POST
	MOVE	*A0(POSTREL),A0,L
	SLL	24,A0		
	SRL	24,A0			;ISOLATE THE UP POST
	CMP	A1,A0			;DOES ONE EXIST?
	JRNE	CONSURC_OK		;BR = YES
	CLR	A0
	NOT	A0
	CLR	A1
	JRUC	CONSURC_NOK		;SIMULATE A NULL MOVE POINT
CONSURC_OK:
	CALLR	CORNRPNT		;UPPER RIGHT CORNER
CONSURC_NOK:
	MOVE	A0,B0
	MOVE	A1,B1
	MOVY	A6,A3

	MOVE	*A2(POSTREL),A0,L
	SRL	24,A0			
	CMP	A4,A0
	JREQ	CONSLRC_OK
	MOVE	A0,A1			;CHECK FOR THE EXISTENCE OF		
	CALLR	GETPOST			;L/R DIAGONAL POST
	MOVE	*A0(POSTREL),A0,L
	SLL	16,A0		
	SRL	24,A0			;ISOLATE THE DOWN POST
	CMP	A1,A0			;DOES ONE EXIST?
	JRNE	CONSLRC_OK		;BR = YES
	CLR	A0
	NOT	A0
	CLR	A1
	JRUC	CONSLRC_NOK		;SIMULATE A NULL MOVE POINT
CONSLRC_OK:
	CALLR	CORNRPNT		;LOWER RIGHT CORNER
CONSLRC_NOK:
	MOVE	A0,B2
	MOVE	A1,B3
	CALLR	ADDCMOVE		;MAKE THIS A CENTER POINT MOVE	
	MOVE	A6,A3

	MOVE	*A2(POSTREL),A0,L
	SLL	8,A0
	SRL	24,A0			
	CMP	A4,A0
	JREQ	CONSLLC_OK
	MOVE	A0,A1			;CHECK FOR THE EXISTENCE OF		
	CALLR	GETPOST			;L/L DIAGONAL POST
	MOVE	*A0(POSTREL),A0,L
	SLL	16,A0		
	SRL	24,A0			;ISOLATE THE DOWN POST
	CMP	A1,A0			;DOES ONE EXIST?
	JRNE	CONSLLC_OK		;BR = YES
	CLR	A0
	NOT	A0
	CLR	A1
	JRUC	CONSLLC_NOK		;SIMULATE A NULL MOVE POINT
CONSLLC_OK:
	CALLR	CORNRPNT		;LOWER LEFT CORNER
CONSLLC_NOK:
	MOVE	A0,B4
	MOVE	A1,B5
	MOVY	A5,A3

	MOVE	*A2(POSTREL),A0,L
	SLL	8,A0
	SRL	24,A0			
	CMP	A4,A0
	JREQ	CONSULC_OK
	MOVE	A0,A1			;CHECK FOR THE EXISTENCE OF		
	CALLR	GETPOST			;U/L DIAGONAL POST
	MOVE	*A0(POSTREL),A0,L
	SLL	24,A0		
	SRL	24,A0			;ISOLATE THE UP POST
	CMP	A1,A0			;DOES ONE EXIST?
	JRNE	CONSULC_OK		;BR = YES
	CLR	A0
	NOT	A0
	CLR	A1
	JRUC	CONSULC_NOK		;SIMULATE A NULL MOVE POINT
CONSULC_OK:
	CALLR	CORNRPNT		;UPPER LEFT CORNER
CONSULC_NOK:
	MOVE	A0,A5
	MOVE	A1,A6

	MMFM	SP,A1,A3		;RETRIEVE THE POST MOVE
	CALLR	EXITPOINTS		;CALCULATE ALL EXIT POINTS
*
*TIE ALL OF THE MOVES TOGETHER
	MOVE	A13,*A3(MOVEUP),W	;TIE IN THE POST
	MOVE	B0,A0
	MOVE	A0,*A3(MOVEUR),W
	MOVE	A7,*A3(MOVERT),W
	MOVE	B2,A0
	MOVE	A0,*A3(MOVEDR),W
	MOVE	A11,*A3(MOVEDN),W
	MOVE	B4,A0
	MOVE	A0,*A3(MOVEDL),W
	MOVE	A9,*A3(MOVELF),W
	MOVE	A5,*A3(MOVEUL),W
	MOVE	@STICKTYP,A0,W
	JRZ	CONSM_ST0		;BR = 4 WAY JOYSTICK
	MOVK	THRU,A0
	MOVB	A0,*A3(MOVETYPE)
CONSM_ST0:
	MOVE	A8,A8			;MOVE POINT TO THE RIGHT OF POST
	JRZ	CONSM0
***	MOVE	A9,*A8(MOVELF),W	;TIE IN RIGHT MOVE POINT
	MOVE	A1,*A8(MOVELF),W
	MOVE	A11,*A8(MOVEDL),W
	MOVE	A13,*A8(MOVEUL),W
	CLR	A0			;MOVK	HORBAR,A0
	MOVB	A0,*A8(MOVETYPE)
	MOVE	B2,A0
	MOVE	A0,*A8(MOVEDN),W
	MOVE	B0,A0
	MOVE	A0,*A8(MOVEUP),W

	MOVE	A14,A14			;SUBSTITUTE LATERAL FOR DIAGONAL
	JRNZ	CONSM_A80		;IF THE DIAGONAL DOESN'T EXIST
	MOVE	B1,B1	
	JRZ	CONSM_A8A
	MOVE	B0,A0
	MOVE	A0,*A8(MOVEUL),W
	JRUC	CONSM_A80
CONSM_A8A:
	MOVE	A1,*A8(MOVEUL),W
CONSM_A80:
	MOVE	A12,A12
	JRNZ	CONSM0
	MOVE	B3,B3
	JRZ	CONSM_A8B
	MOVE	B2,A0
	MOVE	A0,*A8(MOVEDL),W
	JRUC	CONSM0
CONSM_A8B:
	MOVE	A1,*A8(MOVEDL),W

CONSM0:
	MOVE	A10,A10			;MOVE POINT TO THE LEFT OF POST
	JRZ	CONSM1	
***	MOVE	A7,*A10(MOVERT),W
	MOVE	A1,*A10(MOVERT),W
	MOVE	A11,*A10(MOVEDR),W
	MOVE	A13,*A10(MOVEUR),W
	CLR	A0			;MOVK	HORBAR,A0
	MOVB	A0,*A10(MOVETYPE)
	MOVE	B4,A0
	MOVE	A0,*A10(MOVEDN),W
	MOVE	A5,*A10(MOVEUP),W

	MOVE	A14,A14			;SUBSTITUTE LATERAL FOR DIAGONAL
	JRNZ	CONSM_A100		;IF THE DIAGONAL DOESN'T EXIST

	MOVE	A6,A6
	JRZ	CONSM_A10A
	MOVE	A5,*A10(MOVEUR),W
	JRUC	CONSM_A100
CONSM_A10A:
	MOVE	A1,*A10(MOVEUR),W

CONSM_A100:
	MOVE	A12,A12
	JRNZ	CONSM1

	MOVE	B5,B5
	JRZ	CONSM_A10B
	MOVE	B4,A0
	MOVE	A0,*A10(MOVEDR),W
	JRUC	CONSM1
CONSM_A10B:
	MOVE	A1,*A10(MOVEDR),W

CONSM1:
	MOVE	A12,A12			;MOVE POINT BELOW THE POST
	JRZ	CONSM2	
***	MOVE	A13,*A12(MOVEUP),W
	MOVE	A1,*A12(MOVEUP),W
	MOVE	A7,*A12(MOVEUR),W
	MOVE	A9,*A12(MOVEUL),W
	MOVK	VERTBAR,A0
	MOVB	A0,*A12(MOVETYPE)
	MOVE	B2,A0
	MOVE	A0,*A12(MOVERT),W
	MOVE	B4,A0
	MOVE	A0,*A12(MOVELF),W

	MOVE	A8,A8			;SUBSTITUTE LATERAL FOR DIAGONAL
	JRNZ	CONSM_A120		;IF THE DIAGONAL DOESN'T EXIST

	MOVE	A3,A3
	JRZ	CONSM_A12A
	MOVE	A1,*A12(MOVEUR),W
	JRUC	CONSM_A120
CONSM_A12A:
	MOVE	B2,A0
	MOVE	A0,*A12(MOVEUR),W

CONSM_A120:
	MOVE	A10,A10
	JRNZ	CONSM2

	MOVE	A3,A3
	JRZ	CONSM_A12B
	MOVE	A1,*A12(MOVEUL),W
	JRUC	CONSM2
CONSM_A12B:
	MOVE	B4,A0
	MOVE	A0,*A12(MOVEUL),W

CONSM2:
	MOVE	A14,A14			;MOVE POINT ABOVE THE POST
	JRZ	CONSM3	
***	MOVE	A11,*A14(MOVEDN),W
	MOVE	A1,*A14(MOVEDN),W
	MOVE	A7,*A14(MOVEDR),W
	MOVE	A9,*A14(MOVEDL),W
	MOVK	VERTBAR,A0
	MOVB	A0,*A14(MOVETYPE)
	MOVE	B0,A0
	MOVE	A0,*A14(MOVERT),W
	MOVE	A5,*A14(MOVELF),W

	MOVE	A8,A8			;SUBSTITUTE LATERAL FOR DIAGONAL
	JRNZ	CONSM_A140		;IF THE DIAGONAL DOESN'T EXIST

	MOVE	A3,A3
	JRZ	CONSM_A14A
	MOVE	A1,*A14(MOVEDR),W
	JRUC	CONSM_A140
CONSM_A14A:
	MOVE	B0,A0
	MOVE	A0,*A14(MOVEDR),W

CONSM_A140:
	MOVE	A10,A10
	JRNZ	CONSM3

	MOVE	A3,A3
	JRZ	CONSM_A14B
	MOVE	A1,*A14(MOVEDL),W
	JRUC	CONSM3
CONSM_A14B:
	MOVE	A5,*A14(MOVEDL),W

CONSM3:
	MOVE	B1,B1			;MOVE POINT UP/RIGHT OF POST
	JRZ	CONSM_B10
	MOVE	B1,A0
	MOVE	A1,*A0(MOVEDL),W
	MOVE	A7,*A0(MOVEDN),W
	MOVE	A13,*A0(MOVELF),W
	MOVE	@STICKTYP,A0,W
	JRZ	CONSM_ST1		;BR = 4 WAY JOYSTICK
	MOVE	B0,A0
	MOVK	THRU,B0
	MOVB	B0,*B1(MOVETYPE)
	MOVE	A0,B0
CONSM_ST1:
	JRUC	CONSM4
CONSM_B10:
	MOVE	A14,A14			;SUBSTITUTE LATERAL FOR DIAGONAL
	JRZ	CONSM_B11		;IF THE DIAGONAL DOESN'T EXIST

	MOVE	A13,*A3(MOVEUR),W
	JRUC	CONSM4
CONSM_B11:
	MOVE	A7,*A3(MOVEUR),W

CONSM4:
	MOVE	B3,B3			;MOVE POINT DOWN/RIGHT OF POST
	JRZ	CONSM_B30
	MOVE	B3,A0
	MOVE	A1,*A0(MOVEUL),W
	MOVE	A7,*A0(MOVEUP),W
	MOVE	A11,*A0(MOVELF),W
	MOVE	@STICKTYP,A0,W
	JRZ	CONSM_ST2		;BR = 4 WAY JOYSTICK
	MOVE	B0,A0
	MOVK	THRU,B0
	MOVB	B0,*B3(MOVETYPE)
	MOVE	A0,B0
CONSM_ST2:
	JRUC	CONSM5
CONSM_B30:
	MOVE	A12,A12			;SUBSTITUTE LATERAL FOR DIAGONAL
	JRZ	CONSM_B31		;IF THE DIAGONAL DOESN'T EXIST
	MOVE	A11,*A3(MOVEDR),W
	JRUC	CONSM5
CONSM_B31:
	MOVE	A7,*A3(MOVEDR),W

CONSM5:
	MOVE	B5,B5			;MOVE POINT DOWN/LEFT OF POST
	JRZ	CONSM_B50
	MOVE	B5,A0
	MOVE	A1,*A0(MOVEUR),W
	MOVE	A9,*A0(MOVEUP),W
	MOVE	A11,*A0(MOVERT),W
	MOVE	@STICKTYP,A0,W
	JRZ	CONSM_ST3		;BR = 4 WAY JOYSTICK
	MOVE	B0,A0
	MOVK	THRU,B0
	MOVB	B0,*B5(MOVETYPE)
	MOVE	A0,B0
CONSM_ST3:
	JRUC	CONSM6
CONSM_B50:
	MOVE	A12,A12			;SUBSTITUTE LATERAL FOR DIAGONAL
	JRZ	CONSM_B51		;IF THE DIAGONAL DOESN'T EXIST
	MOVE	A11,*A3(MOVEDL),W
	JRUC	CONSM6
CONSM_B51:
	MOVE	A9,*A3(MOVEDL),W

CONSM6:
	MOVE	A6,A6			;MOVE POINT UP/LEFT OF POST
	JRZ	CONSM_A60
	MOVE	A1,*A6(MOVEDR),W
	MOVE	A9,*A6(MOVEDN),W
	MOVE	A13,*A6(MOVERT),W
	MOVE	@STICKTYP,A0,W
	JRZ	CONSM_ST4		;BR = 4 WAY JOYSTICK
	MOVK	THRU,A0
	MOVB	A0,*A6(MOVETYPE)
CONSM_ST4:
	JRUC	CONSM7
CONSM_A60:
	MOVE	A14,A14			;SUBSTITUTE LATERAL FOR DIAGONAL
	JRZ	CONSM_A61		;IF THE DIAGONAL DOESN'T EXIST
	MOVE	A13,*A3(MOVEUL),W
	JRUC	CONSM7
CONSM_A61:
	MOVE	A9,*A3(MOVEUL),W

CONSM7:
	INC	A4			;INCREMENT POST COUNT
	ADDI	POSTSIZE,A2
	MOVE	*A2(POSTPOS),A5,L
	JRNZ	CONSLP
CONSMX
	MMFM	SP,B0,B1,B2,B3,B4,B5
	MMFM	SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14
	RETS

*
*8 WAY JOYSTICK MOVEMENT
CONS_8WAY:
	MOVE	A8,A8			;MOVE POINT TO THE RIGHT OF POST
	JRZ	CONS8W0
	MOVE	A9,*A8(MOVELF),W	;LEFT MOVE
	MOVE	A11,*A8(MOVEDL),W
	MOVE	A13,*A8(MOVEUL),W
	CLR	A0			;MOVK	HORBAR,A0
	MOVB	A0,*A8(MOVETYPE)

CONS8W0:
	MOVE	A10,A10			;MOVE POINT TO THE LEFT OF POST
	JRZ	CONS8W1	
	MOVE	A7,*A10(MOVERT),W
	MOVE	A11,*A10(MOVEDR),W
	MOVE	A13,*A10(MOVEUR),W
	CLR	A0			;MOVK	HORBAR,A0
	MOVB	A0,*A10(MOVETYPE)

CONS8W1:
	MOVE	A12,A12			;MOVE POINT BELOW THE POST
	JRZ	CONS8W2	
	MOVE	A13,*A12(MOVEUP),W
	MOVE	A7,*A12(MOVEUR),W
	MOVE	A9,*A12(MOVEUL),W
	MOVK	VERTBAR,A0
	MOVB	A0,*A12(MOVETYPE)


CONS8W2:
	MOVE	A14,A14			;MOVE POINT ABOVE THE POST
	JRZ	CONS8W3	
	MOVE	A11,*A14(MOVEDN),W
	MOVE	A7,*A14(MOVEDR),W
	MOVE	A9,*A14(MOVEDL),W
	MOVK	VERTBAR,A0
	MOVB	A0,*A14(MOVETYPE)

CONS8W3:
	JRUC	CONSM7

**************************************************************************
*                                                                        *
* MOVEPNT - CALCULATE A MOVE POINT BETWEEN TWO POSTS AND ADD IT TO THE	 *
* 	  MOVE TABLE.							 *
* A0 = POST MAP INDEX OF SECOND POST					 *
* A4 = POST MAP INDEX OF CURRENT POST					 *
* A5 = [Y,X] OF CURRENT POST						 *
* RETURNS								 *
* A0 = MOVE INDEX(IF = 0FFFFFFFFH THEN NO POINT WAS ESTABLISHED)	 *
* A1 = MOVE ENTRY ADDRESS(0 IF NO MOVE POINT WAS ESTABLISHED		 *
* EQ IF NO MOVE POINT WAS ESTABLISHED					 *
*                                                                        *
**************************************************************************
MOVEPNT
	PUSH	A3
	CMP	A0,A4
	JREQ	MOVEPFL			;SAME POST, NO MOVE TO FORM
	CALLR	GETPOST			;GET THE POST
	MOVE	*A0(POSTPOS),A1,L
	MOVE	A5,A0
	CALLA	MIDPOINT
	MOVE	A0,A3
	CALLR	ADDMOVE
	JRZ	MOVEPX
	MMTM	SP,A0,A1
	CALLR	ADDAMOVE		;MAKE THIS AN AUXILARY MOVE ALSO
	MMFM	SP,A0,A1
	MOVE	A1,A1			;NE
	JRUC	MOVEPX
MOVEPFL
	CLR	A0
	NOT	A0
	CLR	A1			;EQ	
MOVEPX
	PULL	A3
	RETS

**************************************************************************
*                                                                        *
* CORNRPNT - CREATE A CORNER MOVE POINT BETWEEN TWO POSTS AND		 *
*	     ADD IT TO THE MOVE TABLE.					 *
* A3 = [Y,X] OF CORNER POINT						 *
* RETURNS								 *
* A0 = MOVE INDEX(IF = 0FFFFFFFFH THEN NO POINT WAS ESTABLISHED)	 *
* A1 = MOVE ENTRY ADDRESS(0 IF NO MOVE POINT WAS ESTABLISHED		 *
* EQ IF NO MOVE POINT WAS ESTABLISHED					 *
*                                                                        *
**************************************************************************
CORNRPNT
	MOVX	A3,A0
	SEXT	A0
	JRN	CORNRPFL		;X COORDINATE IS INVALID
	MOVY	A3,A0
	SRA	16,A0
	JRN	CORNRPFL		;Y COORDINATE IS INVALID
	CALLR	ADDMOVE
	JRZ	CORNRPX
	MOVE	A1,A1			;NE
	JRUC	CORNRPX
CORNRPFL
	CLR	A0
	NOT	A0
	CLR	A1			;EQ	
CORNRPX
	RETS

**************************************************************************
*                                                                        *
* EXITPOINTS - CALCULATE EXIT POINTS, IF ANY FROM THIS POST.		 *
* A1 = POST MOVE INDEX							 *
* A3 = POST MOVE ADDRESS						 *
* A5 = UL INDEX								 *
* A6 = UL ADDRESS							 *
* A7 = RIGHT INDEX							 *
* A8 = RIGHT ADDRESS							 *
* A9 = LEFT INDEX							 *
* A10 = LEFT ADDRESS							 *
* A11 = DOWN INDEX							 *
* A12 = DOWN ADDRESS							 *
* A13 = UP INDEX							 *
* A14 = UP ADDRESS							 *
* B0 = UR INDEX								 *
* B1 = UR ADDRESS							 *
* B2 = LR INDEX								 *
* B3 = LR ADDRESS							 *
* B4 = LL INDEX								 *
* B5 = LL ADDRESS							 *
*                                                                        *
**************************************************************************
****EXITPOINTS:
****	MMTM	SP,A0,A1,A2,A4
****	MOVE	A13,A13
****	JRNN	NOTOPEXIT
****	CLR	A2			;MOVK	UP,A2
****	MOVE	B2,A4
****	MOVE	A7,A0
****	MOVE	A8,A1
****	CALLR	CALCA1GT
****	MOVE	B4,A4
****	MOVE	A9,A0
****	MOVE	A10,A1
****	CALLR	CALCA1LT
****NOTOPEXIT:
****	MOVE	A7,A7
****	JRNN	NORIGHTEXIT	
****	MOVK	RIGHT,A2
****	MOVE	A5,A4
****	MOVE	A13,A0
****	MOVE	A14,A1
****	CALLR	CALCA1GT
****	MOVE	B4,A4
****	MOVE	A11,A0
****	MOVE	A12,A1
****	CALLR	CALCA1LT
****NORIGHTEXIT:
****	MOVE	A11,A11
****	JRNN	NODOWNEXIT
****	MOVK	DOWN,A2
****	MOVE	B0,A4
****	MOVE	A7,A0
****	MOVE	A8,A1
****	CALLR	CALCA1LT
****	MOVE	A5,A4
****	MOVE	A9,A0
****	MOVE	A10,A1
****	CALLR	CALCA1GT
****NODOWNEXIT:
****	MOVE	A9,A9
****	JRNN	NOLEFTEXIT
****	MOVK	LEFT,A2
****	MOVE	B0,A4
****	MOVE	A13,A0
****	MOVE	A14,A1
****	CALLR	CALCA1LT
****	MOVE	B2,A4
****	MOVE	A11,A0
****	MOVE	A12,A1
****	CALLR	CALCA1GT
****NOLEFTEXIT:
****	MMFM	SP,A0,A1,A2,A4
****	RETS

EXITPOINTS:
	MMTM	SP,A0,A1,A2,A4
	MOVE	A5,A5
	JRNN	NOULEXIT
	MOVK	LEFT,A2
	MOVE	B0,A4
	MOVE	A13,A0
	MOVE	A14,A1
	CALLR	CALCA1LT
	MOVI	UP,A2
	MOVE	B4,A4
	MOVE	A9,A0
	MOVE	A10,A1
	CALLR	CALCA1LT
NOULEXIT:
	MOVE	B0,B0
	JRNN	NOUREXIT	
	MOVK	RIGHT,A2
	MOVE	A5,A4
	MOVE	A13,A0
	MOVE	A14,A1
	CALLR	CALCA1GT
	MOVI	UP,A2
	MOVE	B2,A4
	MOVE	A7,A0
	MOVE	A8,A1
	CALLR	CALCA1GT
NOUREXIT:
	MOVE	B2,B2
	JRNN	NODREXIT
	MOVK	DOWN,A2
	MOVE	B0,A4
	MOVE	A7,A0
	MOVE	A8,A1
	CALLR	CALCA1LT
	MOVI	RIGHT,A2
	MOVE	B4,A4
	MOVE	A11,A0
	MOVE	A12,A1
	CALLR	CALCA1LT
NODREXIT:
	MOVE	B4,B4
	JRNN	NODLEXIT
	MOVI	LEFT,A2
	MOVE	B2,A4
	MOVE	A11,A0
	MOVE	A12,A1
	CALLR	CALCA1GT
	MOVI	DOWN,A2
	MOVE	A5,A4
	MOVE	A9,A0
	MOVE	A10,A1
	CALLR	CALCA1GT
NODLEXIT:
	MMFM	SP,A0,A1,A2,A4
	RETS

*EXIT POINT CALCULATION ROUTINES
*NOTE: USE ONLY WITH THE ROUTINE EXITPOINTS
*UP AND LEFT EXIT POINT CALC
CALCA1GT:
	MMTM	SP,A3,A5,A6,A14
	MOVE	A0,A0
	JRN	CALCEXITX
	MOVE	*A3(POSTPOS),A3,L
	MOVE	A1,A6			;STORE MOVE DATA AREA
	MOVE	*A1(MOVEPOS),A1,L
	SUBXY	A1,A3			;POSTPOS - MOVEPOS
	JRUC	CALCEXITADD
*RIGHT AND DOWN EXIT POINT CALC
CALCA1LT:
	MMTM	SP,A3,A5,A6,A14
	MOVE	A0,A0
	JRN	CALCEXITX
	MOVE	*A3(POSTPOS),A3,L
	MOVE	A1,A6			;STORE MOVE DATA AREA
	MOVE	*A1(MOVEPOS),A1,L
	MOVE	A1,A5
	SUBXY	A3,A1			;MOVEPOS - POSTPOS
	MOVE	A1,A3	
	MOVE	A5,A1
CALCEXITADD:
	HALFXY	A3			;DIVIDE THE X AND Y HALVES BY 2
	HALFXY	A3			;DO IT AGAIN
	RL	16,A3
	ADDXY	A1,A3
	CALLR	ADDEMOVE		;LET US ADD THIS EXIT MOVE
	JREQ	CALCEXITX		;NOT HARDLY
	CALLR	LEGAL_EXIT		;SEE IF THE EXIT POINT IS LEGAL
	MOVE	A1,*A6(MOVEEPTR),L	;STORE POINTER TO THE EXIT MOVE
	MOVB	A2,*A1(EMOVEDIR)
	MOVE	A4,*A1(EMOVERET),W	;STORE THE RETURN CENTER POINT
	MOVE	A6,*A1(EMOVEMPTR),L	;STORE THE CORRESPONDING MOVE POINT
CALCEXITX:
	MMFM	SP,A3,A5,A6,A14
	RETS
	
**************************************************************************
*                                                                        *
* LEGAL_EXIT - DETERMINE IF THIS EXITPOINT IS LEGAL			 *
* A0 = INDEX OF EXIT MOVE						 *
* A1 = PTR TO EXIT MOVE ENTRY						 *
* RETURNS:								 *
*	EXIT MOVE STUFFED WITH THE CORRECT TYPE				 *
*                                                                        *
**************************************************************************
LEGAL_EXIT:
	MMTM	SP,A0,A2,A3,A4,A5,A6,A14
	CLR	A6
	NOT	A6
	MOVB	A6,*A1(EMOVEPLYR)	;MARK THIS SPOT UNTAKEN
	MOVE	*A1(EMOVEPOS),A6,L	;GET THE POSITION
	MOVE	@BOUNDRIES,A4,L
LEGAL_E_LP:
	MOVE	*A4+,A2,L		;GET THE [ULY,ULX] OF BOUNDRY BOX
	JRNZ	LEGAL_E_CK
	MOVI	TYPE_CLIFF,A6
	MOVE	A6,*A1(EMOVETYPE),W	;STORE THE TYPE
	JRUC	LEGAL_E_X
LEGAL_E_CK:
	MOVE	*A4+,A3,L		;GET [LRY,LRX] OF BOUNDRY BOX
	MOVE	*A4+,A5,W
	CLR	A0
	NOT	A0
	CMPI	TYPE_PIT,A5		;IS THIS A PIT?
	JREQ	LEGAL_E_PITCK		;BR = YES
	CMPI	TYPE_LAKE,A5		;IS IT A LAKE
	JREQ	LEGAL_E_INCK		;BR = YES
	CMPI	TYPE_VOLCANO,A5		;IS IT A VOLCANO
	JREQ	LEGAL_E_INCK		;BR = YES
	JRUC	LEGAL_E_LP		;BR = UNKNOWN, DON'T CHECK
LEGAL_E_PITCK:
	MOVE	*A4+,A0,L		;GET THE MID POINT IN CASE
LEGAL_E_INCK:
	CMPXY	A2,A6			;COMPARE UL TO UL
	JRYLT	LEGAL_E_LP		;BR = NOT INSIDE THIS BOUNDRY
	JRXLT	LEGAL_E_LP		;BR = NOT INSIDE THIS BOUNDRY
	CMPXY	A3,A6
	JRYGT	LEGAL_E_LP		;BR = NOT INSIDE THIS BOUNDRY
	JRXGT	LEGAL_E_LP		;BR = NOT INSIDE THIS BOUNDRY
	MOVE	A5,*A1(EMOVETYPE),W	;STORE THIS VITAL INFO
	MOVE	A0,*A1(EMOVEPIT),L
LEGAL_E_X:
	MMFM	SP,A0,A2,A3,A4,A5,A6,A14
	RETS


**************************************************************************
*                                                                        *
* INITMOVE - INITIALIZE THE MOVE MAP					 *
*                                                                        *
**************************************************************************
INITMOVE
	MMTM	SP,A1,A2,A3
	MOVI	MOVEMAP,A1
	MOVI	MOVEEND,A2
	CLR	A3
	NOT	A3			;INITIALIZE TO ALL F'S
	CALLA	FILBLOCK
	CLR	A1
	MOVE	A1,@MOVECNT,W		;CLEAR THE COUNTER
	MMFM	SP,A1,A2,A3
	RETS

**************************************************************************
*                                                                        *
* TOMOVE - POSITION AN OBJECT ON A MOVE POINT				 *
* A0 = ENTRY TO MOVE TABLE						 *
* A8 = OBJECT TO POSITION						 *
*                                                                        *
**************************************************************************
TOMOVE
****	MMTM	SP,A0,A2,A3,A4
	PUSH	A3
	MOVE	*A0(MOVEPOS),A3,L
	CALLA	OBJ_TO_PNT
****	CLR	A2
****	MOVY	A3,A2
****	SLL	16,A3
****	MOVE	A8,A0
****	MOVE	*A0(OFLAGS),A4,W
****	CALLA	GANISAG
	PULL	A3
****	MMFM	SP,A0,A2,A3,A4
	RETS

**************************************************************************
*                                                                        *
* GETMOVE - GET A MOVE TABLE ENTRY					 *
* A0 = MOVE #								 *
* RETURNS								 *
* A0 = PTR TO MOVE TABLE ENTRY						 *
*                                                                        *
**************************************************************************
GETMOVE
	PUSH	A1
	MOVI	MOVESIZE,A1
	MPYU	A0,A1
	MOVE	A1,A0
	ADDI	MOVEMAP,A0
	PULL	A1
	RETS

**************************************************************************
*								         *
* TWO_MOVES - GET THE MOVE POINT THAT IS TWO MOVES AWAY IN		 *
* 		THE GIVEN DIRECTION.					 *
* A0 = DIRECTION TO PROCEED						 *
* A1 = PTR TO MOVE POINT DATA AREA					 *
* RETURNS:								 *
* 	 Z = NO MOVE IN THAT DIRECTION					 *
* 	NZ = FOUND MOVE (A1 = PTR TO MOVE DATA)				 *
* NOTE: A14 IS DESTROYED						 *
*								         *
**************************************************************************
TWO_MOVES:
	MMTM	SP,A0,A2
	MOVE	A0,A2
	SLL	4,A2		;MOVE RELATIONS ARE A WORD APART
	ADDI	MOVEREL,A2	;OFFSET FOR NEXT MOVE
	MOVE	A1,A0
	ADD	A2,A0
	MOVE	*A0,A0,W
	JRN	TWO_MOVESFL
	CALLR	GETMOVE		;LOAD THAT MOVE	
	ADD	A2,A0	
	MOVE	*A0,A0,W
	JRN	TWO_MOVESFL
	CALLR	GETMOVE		;LOAD THE SECOND MOVE
	MOVE	A0,A1
	JRUC	TWO_MOVESX
TWO_MOVESFL:
	SETZ
TWO_MOVESX:
	MMFM	SP,A0,A2
	RETS

**************************************************************************
*								         *
* ONE_MOVE - GET THE MOVE POINT THAT IS ADJACENT TO THIS ONE IN 	 *
* 		THE GIVEN DIRECTION.					 *
* A0 = PTR TO MOVE POINT DATA AREA					 *
* A1 = DIRECTION TO GO							 *
* RETURNS:								 *
* 	 Z = NO MOVE IN THAT DIRECTION					 *
* 	NZ = FOUND MOVE (A1 = PTR TO MOVE DATA)				 *
* NOTE: A14 IS DESTROYED						 *
*	INPUT IS BACKWARDS FROM TWO_MOVES, SO BE CAREFUL!		 *
*								         *
**************************************************************************
ONE_MOVE:
	PUSH	A0
	SLL	4,A1		;MOVE RELATIONS ARE A WORD APART
	ADDI	MOVEREL,A1	;OFFSET FOR NEXT MOVE
	ADD	A1,A0
	MOVE	*A0,A0,W
	JRN	ONE_MOVEFL
	CALLR	GETMOVE		;LOAD THAT MOVE	
	MOVE	A0,A1
	JRUC	ONE_MOVEX
ONE_MOVEFL:
	SETZ
ONE_MOVEX:
	PULL	A0
	RETS

**************************************************************************
*								         *
* FIND_CMOVE_X - FIND A RANDOM, OPEN, CENTER MOVE WITH THE GIVEN	 *
* 		X COORDINATE						 *
* A3 = X COORDINATE							 *
* RETURNS:								 *
* 	 Z = NO CENTER POINT FOUND					 *
* 	NZ = CENTER POINT FOUND						 *
* 		A0 = PTR TO CLOSEST CENTER POINT DATA AREA		 *
* 		A3 = [Y,X] CLOSEST CENTER POINT				 *
*								         *
**************************************************************************
FIND_CMOVE_X:
	MMTM	SP,A1,A4,A5,A6
	CALLR	LIST_CMOVE_X
	JRZ	FIND_CMOVE_LIST_X
	JRUC	FIND_CMOVE_LIST

**************************************************************************
*								         *
* FIND_CMOVE_Y - FIND A RANDOM, OPEN, CENTER MOVE WITH THE GIVEN	 *
* 		Y COORDINATE						 *
* A3 = Y COORDINATE							 *
* RETURNS:								 *
* 	 Z = NO CENTER POINT FOUND					 *
* 	NZ = CENTER POINT FOUND						 *
* 		A0 = PTR TO CLOSEST CENTER POINT DATA AREA		 *
* 		A3 = [Y,X] CLOSEST CENTER POINT				 *
*								         *
**************************************************************************
FIND_CMOVE_Y:
	MMTM	SP,A1,A4,A5,A6
	CALLR	LIST_CMOVE_Y
	JRZ	FIND_CMOVE_LIST_X
*
*ENTRYPOINT: FIND A RANDOM CENTER POINT FROM THE CMOVE_LIST
*A5 = NUMBER OF ACTIVE ELEMENTS
FIND_CMOVE_LIST:
	MOVK	5,A6			;THIS MANY TRIES UNTIL FAILURE
FCMLP:
	MOVE	A5,A0
	CALLA	RANDU			;FIND A CENTER POINT
	DEC	A0			;MAKE IT ZERO BASED
	SLL	5,A0
	ADDI	CMOVE_LIST,A0
	MOVE	*A0,A0,L
	MOVB	*A0(CMOVEEGG),A1	;SPOT EMPTY?
	INC	A1			
	JRNE	FCMNXT			;BR = NO
	MOVB	*A0(CMOVETROG),A1	;IS THE FUTURE OF THIS SPOT CLEAR?
	INC	A1			
	JRNE	FCMNXT			;BR = NO
	MOVE	*A0(CMOVEPOS),A3,L	;GET THE POSITION OF THIS POINT	
	CALLA	DINO_PNT_TST	
	JRZ	FCMHERE
FCMNXT:
	DSJ	A6,FCMLP
*RANDOM FAILURE MODE, JUST LOOK FOR THE FIRST AVAILABLE CENTER
	CLR	A6
FCMCLP:
	MOVE	A6,A0
	SLL	5,A0
	ADDI	CMOVE_LIST,A0
	MOVE	*A0,A0,L
	MOVB	*A0(CMOVEEGG),A1	;SPOT EMPTY?
	INC	A1			
	JRNE	FCMCNXT			;BR = NO
	MOVB	*A0(CMOVETROG),A1	;IS THE FUTURE OF THIS SPOT CLEAR?
	INC	A1			
	JRNE	FCMCNXT			;BR = NO
	MOVE	*A0(CMOVEPOS),A3,L	;GET THE POSITION OF THIS POINT	
	CALLA	DINO_PNT_TST	
	JRZ	FCMHERE
FCMCNXT:
	INC	A6
	DSJ	A5,FCMCLP
	CLR	A0			;NO OPEN SPACES, SET Z WITH THIS
FCMHERE:
	MOVE	A0,A1			;SET OR CLR Z
FIND_CMOVE_LIST_X:
	MMFM	SP,A1,A4,A5,A6
	RETS

NUMCLIST .EQU	15
	.BSS	CMOVE_LIST,NUMCLIST*32,1

**************************************************************************
*								         *
* LIST_CMOVE_X - BUILD A LIST OF ALL OF THE CMOVES WITH THE GIVEN	 *
* 		X COORDINATE.						 *
* A3 = X COORDINATE							 *
* RETURNS:								 *
* 	 Z = NO CENTER MOVES OF THAT X (A5 = 0)				 *
* 	NZ = CENTER MOVE LIST BUILT 					 *
* 		A5 = # OF CMOVES ADDED TO THE LIST			 *
* 		CMOVE_LIST, GLOBAL RAM LOCATION AS THE LIST		 *
*								         *
**************************************************************************
LIST_CMOVE_X:
	MMTM	SP,A0,A1,A4,A6,A7
	CLR	A5
	MOVI	CMOVEMAP,A0
	MOVE	@CMOVECNT,A6,W
	JRZ	LIST_CMOVE_X_X
	MOVI	NUMCLIST,A7			;THIS IS THE MAX WE CAN STUFF
	MOVI	CMOVE_LIST,A4
LIST_CX_LP:
	MOVE	*A0(CMOVEPOS),A1,W
	CMP	A1,A3
	JRNE	LIST_CX_NXT	
	INC	A5
	MOVE	A0,*A4+,L			;ADD THIS ONE TO THE TABLE	
	DEC	A7
LIST_CX_NXT:
	ADDI	CMOVESIZE,A0
	MOVE	A7,A7
	DSJNE	A6,LIST_CX_LP
LIST_CMOVE_X_X:
	MOVE	A5,A5
	MMFM	SP,A0,A1,A4,A6,A7
	RETS
	
**************************************************************************
*								         *
* LIST_CMOVE_Y - BUILD A LIST OF ALL OF THE CMOVES WITH THE GIVEN	 *
* 		Y COORDINATE.						 *
* A3 = Y COORDINATE							 *
* RETURNS:								 *
* 	 Z = NO CENTER MOVES OF THAT Y (A5 = 0)				 *
* 	NZ = CENTER MOVE LIST BUILT 					 *
* 		A5 = # OF CMOVES ADDED TO THE LIST			 *
* 		CMOVE_LIST, GLOBAL RAM LOCATION AS THE LIST		 *
*								         *
**************************************************************************
LIST_CMOVE_Y:
	MMTM	SP,A0,A1,A4,A6,A7
	CLR	A5
	MOVI	CMOVEMAP,A0
	MOVE	@CMOVECNT,A6,W
	JRZ	LIST_CMOVE_Y_X
	MOVI	NUMCLIST,A7			;THIS IS THE MAX WE CAN STUFF
	MOVI	CMOVE_LIST,A4
LIST_CY_LP:
	MOVE	*A0(CMOVEPOS+10H),A1,W
	CMP	A1,A3
	JRNE	LIST_CY_NXT	
	INC	A5
	MOVE	A0,*A4+,L			;ADD THIS ONE TO THE TABLE	
	DEC	A7
LIST_CY_NXT:
	ADDI	CMOVESIZE,A0
	MOVE	A7,A7
	DSJNE	A6,LIST_CY_LP
LIST_CMOVE_Y_X:
	MOVE	A5,A5
	MMFM	SP,A0,A1,A4,A6,A7
	RETS

**************************************************************************
*                                                                        *
* FINDMOVE - FIND A LEGAL MOVE POSITION IN THE MAP.			 *
* A3 = [Y,X] POSITION OF MOVE POINT.					 *
* RETURNS								 *
* 	C = MOVE FOUND							 *
*		 Z = 1							 *
* 		A0 = MOVE INDEX						 *
* 		A1 = MOVE ENTRY ADDRESS					 *
*      NC & Z = NO MOVE FOUND, NO MORE MOVES 				 *	
*      NC & NZ = NO MOVE FOUND						 *
*		A0 = NEW INDEX						 *
*		A1 = NEW MOVE ENTRY ADDRESS				 *
* NOTE: A0,A1 ARE DESTROYED ON FAILURE					 *
*                                                                        *
**************************************************************************
FINDMOVE:
	PUSH	A4
	MOVI	NMOVES,A0
	MOVI	MOVEMAP,A1
FINDMPL:
	MOVE	*A1(MOVEPOS),A4,L
	JRN	FINDMNEW		;WE HAVE A NEW MOVE

	CMP	A3,A4
	JREQ	FINDMFND		;FOUND A MOVE
	ADDI	MOVESIZE,A1
	DSJS	A0,FINDMPL	
	MOVE	A0,A0			;FLAG NO CENTER POINT
	CLRC				;TABLE MEMORY EXHAUSTED
	JRUC	FINDMPX
*NEW MOVE POINT 
FINDMNEW:
	SUBI	NMOVES,A0
	NEG	A0
	MOVE	A1,A1
	CLRC
	JRUC	FINDMPX
*FOUND THE MOVE WE WERE LOOKING FOR
FINDMFND:
	SUBI	NMOVES,A0
	NEG	A0			;SET INDEX #
	MOVE	A1,A1			;SET NE FOR SUCCESS
	SETC
FINDMPX:
	PULL	A4
	RETS

**************************************************************************
*                                                                        *
* ADDMOVE - ADD A MOVE TO THE MOVE MAP					 *
* A3 = [Y,X] POSITION OF MOVE						 *
* RETURNS								 *
* A0 = MOVE INDEX(IF = 0FFFFFFFFH THEN NO POINT WAS ESTABLISHED)	 *
* A1 = MOVE ENTRY ADDRESS						 *
* EQ IF THE MOVE MAP IS FULL						 *
* NOTE: A0,A1 ARE DESTROYED ON FAILURE					 *
*                                                                        *
**************************************************************************
ADDMOVE
	PUSH	A5
	CALLR	FINDMOVE		;CHECK TO SEE IF THERE IS ONE
	JRC	ADDMOVEX		;YES, JUST RETURN IT
	JREQ	ADDMOVEX		;NO, BUT THERE'S NO MORE ENTRIES
	MOVE	A3,*A1(MOVEPOS),L	;STORE THE POSITION
	CLR	A5
	MOVB	A5,*A1(MOVEDSRCH)	;CLEAR THE SEARCH FLAG
	MOVE	@MOVECNT,A5,W
	INC	A5	      		;ADD ONE TO THE COUNT OF CMOVES
	MOVE	A5,@MOVECNT,W
	MOVE	A1,A1			;NZ FOR SUCCESS
ADDMOVEX:
	PULL	A5
	RETS

**************************************************************************
*								         *
* DSRCH_CLR - CLEAR THE STARTING POINT SEARCH MARKS			 *
* NOTE: TRASHES A14							 *
*								         *
**************************************************************************
DSRCH_CLR:
	MMTM	SP,A4,A6
	MOVE	@MOVECNT,A6,W
	JRZ	DSCX		;BR = NO MOVE PNTS?
	MOVI	MOVEMAP,A4
	CLR	A14
DSCLP:
	MOVB	A14,*A4(MOVEDSRCH)	
	ADDI	MOVESIZE,A4
	DSJS	A6,DSCLP	
DSCX:
	MMFM	SP,A4,A6
	RETS
	
**************************************************************************
*								         *
* FREE_MOVE_EGG - UMARK THE MOVE POINT THAT THE GIVEN OBJECTS ANIMATION	 *
* 		POINT IS ON. IF THE CMOVEEGG VALUE OF THIS POINT IS	 *
* 		NOT EQUAL TO THE LOWER BYTE OF THE OBJECTS OID. THEN	 *
* 		NOTHING IS DONE.					 *
* A8 = PTR TO OBJECT							 *
* RETURNS:								 *
* 	NOTHING								 *
*								         *
**************************************************************************
FREE_MOVE_EGG:
	MMTM	SP,A0,A1,A2,A3
	CALLA	GETANIXY
	SRL	16,A3
	MOVY	A2,A3
	CALLA	FINDMOVE		;FIND THE MOVE POINT THIS GUY IS ON
	JRNC	FREE_MOVE_X		;BR = NOT ON A MOVE
	MOVE	*A1(MOVECPTR),A0,L	;IS THIS A CENTER MOVE?
	JRNN	FREE_MOVE_FREE		;BR = YES
	MOVE	*A1(MOVEAPTR),A0,L	;O.K. CHECK AUXILLARY MAP
	JRN	FREE_MOVE_X		;BR = NOT THERE
FREE_MOVE_FREE:
	MOVB	*A0(CMOVEEGG),A2
	MOVB	*A8(OID),A3
	CMP	A2,A3
	JRNE	FREE_MOVE_X
	CLR	A1
	NOT	A1
	MOVB	A1,*A0(CMOVEEGG)	;POOF, IT'S GONE
FREE_MOVE_X:
	MMFM	SP,A0,A1,A2,A3
	RETS


**************************************************************************
*                                                                        *
* CENTER POINT MOVE ROUTINES						 *
*                                                                        *
**************************************************************************
**************************************************************************
*                                                                        *
* INITCMOVE - INITIALIZE THE CENTER MOVE MAP				 *
*                                                                        *
**************************************************************************
INITCMOVE:
	MMTM	SP,A1,A2,A3
	MOVI	CMOVEMAP,A1
	MOVI	CMOVEEND,A2
	CLR	A3
	NOT	A3			;INITIALIZE TO ALL F'S
	CALLA	FILBLOCK
	CLR	A1
	MOVE	A1,@CMOVECNT,W		;CLEAR THE COUNTER
	MMFM	SP,A1,A2,A3
	RETS

**************************************************************************
*                                                                        *
* GETCMOVE - GET THE CENTER MOVE GIVEN THE INDEX INTO THE TABLE		 *
* A0 = CMOVE INDEX							 *
* RETURNS								 *
* A0 = CMOVE ADDRESS							 *
*                                                                        *
**************************************************************************
GETCMOVE
	PUSH	A1
	MOVI	CMOVESIZE,A1
	MPYU	A0,A1
	MOVE	A1,A0
	ADDI	CMOVEMAP,A0
	PULL	A1
	RETS

**************************************************************************
*                                                                        *
* FINDCMOVE - FIND A LEGAL CENTER POINT IN THE MAP.			 *
* A3 = POSITION OF CENTER MOVE POINT TO SEARCH FOR.			 *
* RETURNS								 *
* 	C = MOVE FOUND							 *
*		 Z = 1							 *
* 		A0 = CMOVE INDEX					 *
* 		A1 = CMOVE ENTRY ADDRESS				 *
*      NC & Z = NO MOVE FOUND, NO MORE MOVES 				 *	
*      NC & NZ = NO MOVE FOUND						 *
*		A0 = NEW INDEX						 *
*		A1 = NEW CENTER MOVE ENTRY ADDRESS			 *
* NOTE: A0,A1 ARE DESTROYED ON FAILURE					 *
*                                                                        *
**************************************************************************
FINDCMOVE:
	PUSH	A4
	MOVI	NCMOVES,A0
	MOVI	CMOVEMAP,A1
FINDCPL:
	MOVE	*A1(CMOVEPOS),A4,L
	JRN	FINDCNEW		;WE HAVE A NEW MOVE

	CMP	A3,A4
	JREQ	FINDCPFND		;FOUND A CENTER POINT
	ADDI	CMOVESIZE,A1
	DSJS	A0,FINDCPL	
	MOVE	A0,A0			;FLAG NO CENTER POINT
	CLRC				;TABLE MEMORY EXHAUSTED
	JRUC	FINDCPX
*NEW CENTER 
FINDCNEW:
	SUBI	NCMOVES,A0
	NEG	A0
	MOVE	A1,A1
	CLRC
	JRUC	FINDCPX
*FOUND THE CENTER POINT WE WERE LOOKING FOR
FINDCPFND:
	SUBI	NCMOVES,A0
	NEG	A0			;SET INDEX #
	MOVE	A1,A1			;SET NE FOR SUCCESS
	SETC
FINDCPX:
	PULL	A4
	RETS

**************************************************************************
*                                                                        *
* ADDCMOVE - ADD A POINT TO THE CENTER POINT MAP			 *
* A0 = MOVE INDEX OF THIS CENTER POINT					 *
* A1 = PTR TO MOVE DATA AREA						 *
* A3 = POSITION OF THIS MOVE						 *
* RETURNS								 *
* A0 = CMOVE INDEX(IF = 0FFFFFFFFH THEN NO POINT WAS ESTABLISHED)	 *
* A1 = CMOVE ENTRY ADDRESS						 *
* EQ IF THE CENTER POINT MAP IS FULL OR MOVE INVALID			 *
* NOTE: A0,A1 ARE DESTROYED ON FAILURE					 *
*                                                                        *
**************************************************************************
ADDCMOVE:
	PUSH	A6
	MOVE	A0,A0
	JRN	ADDCMOVEX		;BR = INVALID MOVE
	MOVE	A1,A6			;STORE THE MOVE DATA PTR HERE

	CALLR	FINDCMOVE		;CHECK TO SEE IF THERE IS ONE
	JRC	ADDCMOVEX		;YES, JUST RETURN IT
	JREQ	ADDCMOVEX		;NO MOVE, TABLE FULL

	MOVE	A3,*A1(CMOVEPOS),L	;STORE THE POSITION
	MOVE	A6,*A1(CMOVEMPTR),L	;POINT CMOVE @ MOVE
	MOVE	A1,*A6(MOVECPTR),L	;POINT MOVE @ CMOVE

	MOVE	@CMOVECNT,A6,W
	INC	A6	      		;ADD ONE TO THE COUNT OF CMOVES
	MOVE	A6,@CMOVECNT,W
	MOVE	A1,A1			;NE FOR SUCCESS

ADDCMOVEX:
	PULL	A6
	RETS

**************************************************************************
*                                                                        *
* AUXILARY MOVE POINT ROUTINES						 *
*                                                                        *
**************************************************************************
**************************************************************************
*                                                                        *
* INITAMOVE - INITIALIZE THE AUXILARY MOVE MAP				 *
*                                                                        *
**************************************************************************
INITAMOVE:
	MMTM	SP,A1,A2,A3
	MOVI	AMOVEMAP,A1
	MOVI	AMOVEEND,A2
	CLR	A3
	NOT	A3			;INITIALIZE TO ALL F'S
	CALLA	FILBLOCK
	CLR	A1
	MOVE	A1,@AMOVECNT,W		;CLEAR THE COUNTER
	MMFM	SP,A1,A2,A3
	RETS

**************************************************************************
*                                                                        *
* GETAMOVE - GET THE AUXILARY MOVE GIVEN THE INDEX INTO THE TABLE.	 *
* A0 = AMOVE INDEX							 *
* RETURNS								 *
* A0 = AMOVE ADDRESS							 *
*                                                                        *
**************************************************************************
GETAMOVE
	PUSH	A1
	MOVI	AMOVESIZE,A1
	MPYU	A0,A1
	MOVE	A1,A0
	ADDI	AMOVEMAP,A0
	PULL	A1
	RETS

**************************************************************************
*                                                                        *
* FINDAMOVE - FIND A GIVEN AUXILARY MOVE POINT IN THE MAP.		 *
* A3 = POSITION OF AUXILARY MOVE POINT TO SEARCH FOR.			 *
* RETURNS								 *
* 	C = AUXILARY MOVE FOUND						 *
*		 Z = 1							 *
* 		A0 = AMOVE INDEX					 *
* 		A1 = AMOVE ENTRY ADDRESS				 *
*      NC & Z = NO AUXILARY MOVE FOUND, NO MORE AUXILARY MOVES		 *	
*      NC & NZ = NO AUXILARY MOVE FOUND					 *
*		A0 = NEW INDEX						 *
*		A1 = NEW AUXILARY MOVE ENTRY ADDRESS			 *
* NOTE: A0,A1 ARE DESTROYED ON FAILURE					 *
*                                                                        *
**************************************************************************
FINDAMOVE:
	PUSH	A4
	MOVI	NAMOVES,A0
	MOVI	AMOVEMAP,A1
FINDAPL:
	MOVE	*A1(CMOVEPOS),A4,L
	JRN	FINDANEW		;WE HAVE A NEW AUXILARY MOVE

	CMP	A3,A4
	JREQ	FINDAPFND		;FOUND AN AUXILARY POINT
	ADDI	AMOVESIZE,A1
	DSJS	A0,FINDAPL	
	MOVE	A0,A0			;FLAG NO AUXILARY POINT
	CLRC				;TABLE MEMORY EXHAUSTED
	JRUC	FINDAPX
*THIS MUST BE A NEW AUXILARY MOVE 
FINDANEW:
	SUBI	NAMOVES,A0
	NEG	A0
	MOVE	A1,A1
	CLRC
	JRUC	FINDAPX
*FOUND THE AUXILARY POINT WE WERE LOOKING FOR
FINDAPFND:
	SUBI	NAMOVES,A0
	NEG	A0			;SET INDEX #
	MOVE	A1,A1			;SET NE FOR SUCCESS
	SETC
FINDAPX:
	PULL	A4
	RETS

**************************************************************************
*                                                                        *
* ADDAMOVE - ADD A POINT TO THE AUXILARY MOVE POINT MAP			 *
* A0 = MOVE INDEX OF THIS AUXILARY POINT				 *
* A1 = PTR TO MOVE DATA AREA						 *
* A3 = POSITION OF THIS MOVE						 *
* RETURNS								 *
* A0 = AMOVE INDEX(IF = 0FFFFFFFFH THEN NO POINT WAS ESTABLISHED)	 *
* A1 = AMOVE ENTRY ADDRESS						 *
* EQ IF THE AUXILARY POINT MAP IS FULL OR MOVE INVALID			 *
* NOTE: A0,A1 ARE DESTROYED ON FAILURE					 *
*                                                                        *
**************************************************************************
ADDAMOVE:
	PUSH	A6
	MOVE	A0,A0
	JRN	ADDAMOVEX		;BR = INVALID MOVE
	MOVE	A1,A6			;STORE THE MOVE DATA PTR HERE

	CALLR	FINDAMOVE		;CHECK TO SEE IF THERE IS ONE
	JRC	ADDAMOVEX		;YES, JUST RETURN IT
	JREQ	ADDAMOVEX		;NO MOVE, TABLE FULL

	MOVE	A3,*A1(CMOVEPOS),L	;STORE THE POSITION
	MOVE	A6,*A1(CMOVEMPTR),L	;POINT AMOVE @ MOVE
	MOVE	A1,*A6(MOVEAPTR),L	;POINT MOVE @ CMOVE

	MOVE	@AMOVECNT,A6,W
	INC	A6	      		;ADD ONE TO THE COUNT OF CMOVES
	MOVE	A6,@AMOVECNT,W
	MOVE	A1,A1			;NE FOR SUCCESS

ADDAMOVEX:
	PULL	A6
	RETS

**************************************************************************
*                                                                        *
* EXIT POINT MOVE ROUTINES						 *
*                                                                        *
**************************************************************************
**************************************************************************
*                                                                        *
* INITEMOVE - INITAILIZE EXIT POINT MOVE MAP				 *
*                                                                        *
**************************************************************************
INITEMOVE:
	MMTM	SP,A1,A2,A3
	MOVI	EMOVEMAP,A1
	MOVI	EMOVEEND,A2
	CLR	A3
	NOT	A3			;INITIALIZE TO ALL F'S
	CALLA	FILBLOCK
	CLR	A1
	MOVE	A1,@EMOVECNT,W		;CLEAR THE COUNTER
	MMFM	SP,A1,A2,A3
	RETS

**************************************************************************
*                                                                        *
* GETEMOVE - GET THE EXIT POINT GIVEN THE INDEX INTO THE TABLE		 *
* A0 = EMOVE INDEX							 *
* RETURNS								 *
* A0 = EMOVE ADDRESS							 *
*                                                                        *
**************************************************************************
GETEMOVE
	PUSH	A1
	MOVI	EMOVESIZE,A1
	MPYU	A0,A1
	MOVE	A1,A0
	ADDI	EMOVEMAP,A0
	PULL	A1
	RETS

**************************************************************************
*                                                                        *
* FINDEMOVE - FIND A LEGAL EXIT POINT IN THE MAP.			 *
* A3 = POSITION OF EXIT POINT TO SEARCH FOR.				 *
* RETURNS								 *
* 	C = POINT FOUND							 *
*		 Z = 1							 *
* 		A0 = EMOVE INDEX					 *
* 		A1 = EMOVE ENTRY ADDRESS				 *
*      NC & Z = NO POINT FOUND, NO MORE POINTS 				 *	
*      NC & NZ = NO POINT FOUND						 *
*		A0 = NEW INDEX						 *
*		A1 = NEW EXIT POINT ENTRY ADDRESS			 *
* NOTE: A0,A1 ARE DESTROYED ON FAILURE					 *
*                                                                        *
**************************************************************************
FINDEMOVE:
	PUSH	A4
	MOVI	NEMOVES,A0
	MOVI	EMOVEMAP,A1
FINDEPL:
	MOVE	*A1(EMOVEPOS),A4,L
	JRN	FINDENEW		;WE HAVE A NEW EXIT POINT

	CMP	A3,A4
	JREQ	FINDEPFND		;FOUND AN EXIT POINT
	ADDI	EMOVESIZE,A1
	DSJS	A0,FINDEPL	
	MOVE	A0,A0			;FLAG NO CENTER POINT
	CLRC				;TABLE MEMORY EXHAUSTED
	JRUC	FINDEPX
*NEW EXIT 
FINDENEW:
	SUBI	NEMOVES,A0
	NEG	A0
	MOVE	A1,A1
	CLRC
	JRUC	FINDEPX
*FOUND THE EXIT POINT WE WERE LOOKING FOR
FINDEPFND:
	SUBI	NEMOVES,A0
	NEG	A0			;SET INDEX #
	MOVE	A1,A1			;SET NE FOR SUCCESS
	SETC
FINDEPX:
	PULL	A4
	RETS

**************************************************************************
*                                                                        *
* ADDEMOVE - ADD AN EXIT POINT TO THE MAP				 *
* A3 = POSITION OF THIS POINT						 *
* RETURNS								 *
* A0 = EMOVE INDEX(IF = 0FFFFFFFFH THEN NO POINT WAS ESTABLISHED)	 *
* A1 = EMOVE ENTRY ADDRESS						 *
* EQ IF THE EXIT POINT MAP IS FULL OR MOVE INVALID			 *
* NOTE: A0,A1 ARE DESTROYED ON FAILURE					 *
*                                                                        *
**************************************************************************
ADDEMOVE:
	PUSH	A5
	CALLR	FINDEMOVE		;CHECK TO SEE IF THERE IS ONE
	JRC	ADDEMOVEX		;YES, JUST RETURN IT
	JREQ	ADDEMOVEX		;NO MOVE, TABLE FULL
	MOVE	A3,*A1(EMOVEPOS),L	;STORE THE POSITION
	MOVE	@EMOVECNT,A5,W
	INC	A5	      		;ADD ONE TO THE COUNT OF CMOVES
	MOVE	A5,@EMOVECNT,W
	CLR	A5
	MOVE	A5,*A1(EMOVEOBJ),L	;CLEAR THE OBJECT PTR
	MOVE	A1,A1			;NE FOR SUCCESS
ADDEMOVEX:
	PULL	A5
	RETS

**************************************************************************
*								         *
* FIND_CLOSE_CPNT - FIND THE CLOSEST CENTER POINT TO THE GIVEN POINT	 *
* A1 = [Y,X] POINT							 *
* RETURNS:								 *
* A0 = PTR TO CLOSEST CENTER POINT DATA AREA				 *
* A3 = [Y,X] CLOSEST CENTER POINT					 *
*								         *
**************************************************************************
FIND_CLOSE_CPNT:
	MMTM	SP,A2,A4,A5,A6,A7
	CLR	A3
	CLR	A0		;STORAGE FOR CLOSEST CENTER POINT
	MOVE	@CMOVECNT,A4	
	MOVI	CMOVEMAP,A5	;LET'S SCAN THE CENTER POINT MAP
FIND_CC_LP:
	MOVE	*A5(CMOVEPOS),A2,L
	MOVE	A1,A6
	SUBXY	A2,A6		;GET THE DISTANCE
	ABSXY	A6		;MAKE IT COMMON
	MOVE	A0,A0		;HAVE WE ALREADY STORED A CLOSEST		
	JRZ	FIND_CC_CLOSER	;BR = NO
	CMPXY	A7,A6		;IS THIS POINT CLOSER
	JRXGT	FIND_CC_FAR
	JRYGT	FIND_CC_FAR
FIND_CC_CLOSER:
	MOVE	A6,A7		;KEEP THIS ONE	
	MOVE	A5,A0
	MOVE	A2,A3
FIND_CC_FAR:
	ADDI	CMOVESIZE,A5
	DSJS	A4,FIND_CC_LP
	MMFM	SP,A2,A4,A5,A6,A7
	RETS

**************************************************************************
*								         *
* COUNT_FREE_CMOVES - COUNT THE NUMBER OF CENTER MOVES THAT ARE CURRENTL *
* 			FREE.						 *
* RETURNS:								 *
* 	A0 = COUNT							 *
*								         *
**************************************************************************
COUNT_FREE_CMOVES
	MMTM	SP,A2,A4,A5
	CLR	A0			;COUNTER FOR CENTER POINTS
	MOVE	@CMOVECNT,A4	
	MOVI	CMOVEMAP,A5		;LET'S SCAN THE CENTER POINT MAP
CFC_LP
	MOVB	*A5(CMOVEEGG),A2
	INC	A2
	JRNZ	CFC_NXT
	INC	A0
CFC_NXT
	ADDI	CMOVESIZE,A5
	DSJS	A4,CFC_LP
	MMFM	SP,A2,A4,A5
	RETS

**************************************************************************
*								         *
* FIND_CLOSE_MPNT - FIND THE CLOSEST MOVE POINT TO THE GIVEN POINT	 *
* A1 = [Y,X] POINT							 *
* RETURNS:								 *
* A0 = PTR TO CLOSEST MOVE POINT DATA AREA				 *
* A3 = [Y,X] CLOSEST MOVE POINT						 *
*								         *
**************************************************************************
FIND_CLOSE_MPNT:
	MMTM	SP,A2,A4,A5,A6,A7
	CLR	A3
	CLR	A0		;STORAGE FOR CLOSEST MOVE POINT
	MOVE	@MOVECNT,A4	
	MOVI	MOVEMAP,A5	;LET'S SCAN THE MOVE POINT MAP
FIND_CM_LP:
	MOVE	*A5(MOVEPOS),A2,L
	MOVE	A1,A6
	SUBXY	A2,A6		;GET THE DISTANCE
	ABSXY	A6		;MAKE IT COMMON
	MOVE	A0,A0		;HAVE WE ALREADY STORED A CLOSEST		
	JRZ	FIND_CM_CLOSER	;BR = NO
	CMPXY	A7,A6		;IS THIS POINT CLOSER
	JRXGT	FIND_CM_FAR
	JRYGT	FIND_CM_FAR
FIND_CM_CLOSER:
	MOVE	A6,A7		;KEEP THIS ONE	
	MOVE	A5,A0
	MOVE	A2,A3
FIND_CM_FAR:
	ADDI	MOVESIZE,A5
	DSJS	A4,FIND_CM_LP
	MMFM	SP,A2,A4,A5,A6,A7
	RETS

**************************************************************************
*								         *
* FIND_CLOSE_EPNT - FIND THE CLOSEST EXIT POINT TO THE GIVEN POINT	 *
* A1 = [Y,X] POINT							 *
* RETURNS:								 *
* A0 = PTR TO CLOSEST EXIT POINT DATA AREA				 *
* A3 = [Y,X] CLOSEST EXIT POINT						 *
*								         *
**************************************************************************
FIND_CLOSE_EPNT:
	MMTM	SP,A2,A4,A5,A6,A7
	CLR	A3
	CLR	A0		;STORAGE FOR CLOSEST MOVE POINT
	MOVE	@EMOVECNT,A4	
	MOVI	EMOVEMAP,A5	;LET'S SCAN THE MOVE POINT MAP
FIND_CE_LP:
	MOVE	*A5(EMOVEPOS),A2,L
	MOVE	A1,A6
	SUBXY	A2,A6		;GET THE DISTANCE
	ABSXY	A6		;MAKE IT COMMON
	MOVE	A0,A0		;HAVE WE ALREADY STORED A CLOSEST		
	JRZ	FIND_CE_CLOSER	;BR = NO
	CMPXY	A7,A6		;IS THIS POINT CLOSER
	JRXGT	FIND_CE_FAR
	JRYGT	FIND_CE_FAR
FIND_CE_CLOSER:
	MOVE	A6,A7		;KEEP THIS ONE	
	MOVE	A5,A0
	MOVE	A2,A3
FIND_CE_FAR:
	ADDI	EMOVESIZE,A5
	DSJS	A4,FIND_CE_LP
	MMFM	SP,A2,A4,A5,A6,A7
	RETS

**************************************************************************
*								         *
* 	FIND_FARTHEST_CPNT						 *
* 									 *
* 	FIND THE FARTHEST CENTER POINT GIVEN A LIST OF OBJECTS		 *
* 									 *
* 	ENTRY								 *
* 		A7	[ MIN Y DISTANCE, MIN X DISTANCE ]		 *
* 									 *
* 	EXIT								 *
* 		A1	POINTER TO CLOSEST CENTER POINT DATA AREA	 *
* 									 *
* 	CALL								 *
* 		CALL							 *
*								         *
**************************************************************************

FIND_FARTHEST_CPNT:
	MMTM	SP,A0,A2,A3,A4,A5,A6,A7,A9
	CALLR	DINO_LIST_INIT	; BUILD UP LIST OF DINOS
	CLR	A3		; POINTER TO THE CENTER POINT
	MOVE	A7,A0		; MIN DISTANCES TO THINGS
	MOVE	@CMOVECNT,A4	; COUNT OF CENTER MOVE POINTS
	MOVI	FAR_LOCS,A9	; POINTER TO FAR LOCS TABLE
	CLR	A5
	MOVE	A5,@FAR_NUM,W	; CLEAR NUMBER OF ENTRIES
	MOVI	CMOVEMAP,A5	; POINTER TO BASE MAP
FIND_FC_LP:
	MOVB	*A5(CMOVEEGG),A2	; SPOT EMPTY?
	INC	A2			
	JRNE	FIND_FC_RELOOP	; BR = NOT EMPTY
	MOVE	*A5(CMOVEPOS),A2,L	; [Y,X] OF CPNT IN A2
	CALLR	FIND_CLOSEST_DINO	; FIND THE CLOSEST DINO TO A2
	CALLR	FAR_CHECK		; SEE IF SAVING POINT
	CMPXY	A0,A1			; IS THIS POINT CLOSER
	JRXLT	FIND_FC_RELOOP
	JRYLT	FIND_FC_RELOOP
FIND_FC_FARTHER:
	MOVE	A5,A3		; MOVE POSITION
	MOVE	A1,A0		; MOVE DISTANCE FROM DINO
FIND_FC_RELOOP:
	ADDI	CMOVESIZE,A5
	DSJS	A4,FIND_FC_LP
	MOVE	A3,A3
	JRZ	FIND_FC_RET	; NOTHING WAS FOUND, DUDE
	CALLR	FAR_PICK	; GET US A RANDOM ONE
	MOVE	A3,A1
FIND_FC_RET
	MMFM	SP,A0,A2,A3,A4,A5,A6,A7,A9
	RETS

**************************************************************************
*								         *
* 	FIND_CLOSEST_DINO						 *
* 									 *
* 	FIND THE CLOSEST DINO TO A GIVEN [Y,X]				 *
* 									 *
* 	ENTRY								 *
* 		A2	[Y,X] OF COMPARISON POINT			 *
* 		A7	[Y,X] MINIMUM ACCEPTABLE DISTANCE		 *
* 									 *
* 	EXIT								 *
* 		A1	[DY,DX] MINIMUM DISTANCE			 *
* 									 *
* 	CALL								 *
* 		CALL							 *
*								         *
**************************************************************************

FIND_CLOSEST_DINO:
	MMTM	SP,A0,A8
	MOVI	[7FFFH, 7FFFH],A1	; EVERYTHING'S LESS THAN THIS
	MOVI	DINO_LOC_LIST,A8
FIND_CLOSEST_DINO_LOOP:
	MOVE	*A8+,A0,L		; GET X/Y OF NEXT DINO
	JRZ	FIND_CLOSEST_DONE	; 0 MEANS NO MORE DINOS, DUDE
	SUBXY	A2,A0			; GET THE DISTANCE
	ABSXY	A0			; MAKE IT COMMON
	CMPXY	A1,A0			; IS THIS POINT CLOSER
	JRXGT	FIND_CLOSEST_DINO_LOOP
	JRYGT	FIND_CLOSEST_DINO_LOOP
	MOVE	A0,A1			; SAVE THE NEW DISTANCE AWAY
	JRUC	FIND_CLOSEST_DINO_LOOP
FIND_CLOSEST_DONE
	CMPI	[7FFFH,7FFFH],A1
	JRNZ	FIND_CLOSEST_DINO_RET
	CLR	A1
FIND_CLOSEST_DINO_RET
	MMFM	SP,A0,A8
	RETS

**************************************************************************
*								         *
* 	FAR_CHECK							 *
* 									 *
* 	CHECK TO SEE IF A POINT IS A CERTAIN DISTANCE AWAY,		 *
* 	SAVE IT IF IT IS						 *
* 									 *
* 	ENTRY								 *
* 		A1	DISTANCE TO CLOSEST DINO			 *
* 		A5	CENTER POINT POINTER				 *
* 		A9	CURRENT POINTER TO FAR_LOCS TABLE		 *
* 									 *
* 	EXIT								 *
* 		NOTHING							 *
* 									 *
* 	CALL								 *
* 		CALL							 *
*								         *
**************************************************************************

MIN_DIST1	EQU	3*16
MIN_DIST2	EQU	1*16


FAR_CHECK:
	MMTM	SP,A0
	MOVI	[MIN_DIST1,MIN_DIST2],A0
	CMPXY	A0,A1			; MEET THE MINIMUM REQUIREMENTS?
	JRXLT	FAR_CHECK_2
	JRYLT	FAR_CHECK_2
FAR_CHECK_SAVE
	MOVE	A5,*A9+,L		; SAVE POINT FOR LATER RANDOMNESS
	INCM	@FAR_NUM,W
	JRUC	FAR_CHECK_RET
FAR_CHECK_2
	MOVI	[MIN_DIST2,MIN_DIST1],A0
	CMPXY	A0,A1			; MEET THE MINIMUM REQUIREMENTS?
	JRXLT	FAR_CHECK_RET
	JRYLT	FAR_CHECK_RET
	JRUC	FAR_CHECK_SAVE
FAR_CHECK_RET
	MMFM	SP,A0
	RETS

**************************************************************************
*								         *
* 	FAR_PICK							 *
* 									 *
* 	PICK A RANDOM ENTRY FROM THE FAR LIST				 *
* 									 *
* 	ENTRY								 *
* 		NOTHING							 *
* 									 *
* 	EXIT								 *
* 		A3	CENTER POINT POINTER				 *
* 									 *
* 	CALL								 *
* 		CALL							 *
*								         *
**************************************************************************

FAR_PICK:
	CLR	B0			; FROM 0
	MOVE	@FAR_NUM,B1,W		; TO HOWEVER MANY WE SAVED
	JRZ	FAR_PICK_RET
	DEC	B1			; ZERO BASE THE PUPPY
	CALLA	RANGRAND
	SLL	5,A0
	ADDI	FAR_LOCS,A0
	MOVE	*A0,A3,L		; HI THERE!
FAR_PICK_RET:
	RETS

**************************************************************************
*								         *
* 	DINO_LIST_INIT							 *
* 									 *
* 	INITIALIZE A LIST OF THE DINO POINTS				 *
* 									 *
* 	ENTRY								 *
* 		NOTHING							 *
* 									 *
* 	EXIT								 *
* 		NOTHING							 *
* 									 *
* 	CALL								 *
* 		CALL							 *
*								         *
**************************************************************************

DINO_LIST_INIT:
	MMTM	SP,A0,A1,A2,A3,A7,A8
 	MOVE	@DINOS,A8,L		; START OF DINO SUPP LIST
	JRZ	DINO_LIST_INIT_RET
	MOVI	DINO_LOC_LIST,A7	; START OF DINO LOC LIST
	MOVI	MAXDINOS,A3
DINO_LIST_INIT_LOOP
	MOVE	*A8(OID),A2,W		; GET THE ID
	SRL	4,A2			; MASK OFF THE IDENTIFIER
	SLL	4,A2
	CMPI	DINOOID,A2		; CHECK TO SEE IF DINO
	JRNZ	DINO_LIST_INIT_RELOOP	; BR = NO DINO
	CALLA	OBJ_WHOLE_CENT		; GET THE CENTER POINT
	JRNC	DINO_LIST_INIT_RELOOP	; WOW, THE DINO IS HOSE'D
	MOVE	A1,*A7+,L		; ADD TO LIST
;
DINO_LIST_INIT_RELOOP
	DEC	A3
	JRZ	DINO_LIST_FULL		; NO MORE ROOM AT THE INN
	MOVE	*A8(OSLINK),A8,L	; GET NEXT LINK IN CHAIN
	JRNZ	DINO_LIST_INIT_LOOP
DINO_LIST_FULL
	CLR	A0
	MOVE	A0,*A7,L		; CLEAR LAST ELEMENT
DINO_LIST_INIT_RET
	MMFM	SP,A0,A1,A2,A3,A7,A8
	RETS

**************************************************************************
*                                                                        *
* BOUNDRY_CHECK - CHECK AN OBJECT AGAINST THE BOUNDRY MAP		 *
* A1 = CURRENT DIRECTION OF OBJECT					 *
* A8 = PTR TO OBJECT							 *
* RETURNS:								 *
* 	  Z = NO BOUNDRY VIOLATIONS					 *
*        NZ = BOUNDRY VIOLATIONS!		 			 *
* A5 =  BOUNDRY TYPE, 0=CLIFF, 1=PIT					 *
* A6 =  IF TYPE 1, THEN = CENTER POINT OF BOUNDRY AREA			 *
*                                                                        *
**************************************************************************
BOUNDRY_CHECK:
	MMTM	SP,A2,A3,A4
	MOVE	@BOUNDRIES,A4,L
BCKLPA2:
	MOVE	*A4+,A2,L		;GET THE [ULY,ULX] OF BOUNDRY BOX
	JRZ	BOUNDRYX		;BR = NO MORE BOUNDRIES TO CHECK
BCKLP:
	MOVE	*A4+,A3,L		;GET [LRY,LRX] OF BOUNDRY BOX
	MOVE	*A4+,A5,W
	JRNZ	BCKIN
*
*EDGE CHECK
	CALLR	QBOXOUT			;CHECK TO SEE IF THE OBJECT IS OUT
	JREQ	BCKLPA2			;BR = DIDN'T EXCEED THIS BOUNDRY
BOUNDRYX:
	MMFM	SP,A2,A3,A4
	RETS
*
*INSIDE CHECK
*A5 = BOUNDRY TYPE
BCKIN:
	CMPI	TYPE_LAKE,A5
	JREQ	BCKIN_ONLY
	CMPI	TYPE_VOLCANO,A5
	JREQ	BCKIN_ONLY
*PIT IS DEFAULT
	MOVE	*A4+,A6,L		;GET THE CENTER POINT OF THE PIT
BCKIN_ONLY:
	CALLR	QBOXIN
	JREQ	BCKLPA2
	JRUC	BOUNDRYX

**************************************************************************
*                                                                        *
* QBOXOUT - CHECK IF OBJECT IS COMPLETELY OUT OF BOX.			 *
* A2 = BOX TOP LEFT [Y,X]						 *
* A3 = BOX BOTTOM RIGHT [Y,X]						 *
* A8 = PTR TO OBJECT							 *
* RETURNS:								 *
* 	Z = TOTALLY OR PARTIALLY INSIDE BOX				 *
* 	NZ = COMPLETELY OUTSIDE OF BOX					 *
* NOTE: TRASHES A14							 *
*                                                                        *
**************************************************************************
QBOXOUT:
	MMTM	SP,A1,A2,A3,A4
	MOVE	*A8(OYPOS),A4,W
	MOVE	*A8(OXPOS),A1,W
	SLL	16,A4
	MOVX	A1,A4	       		;GET TOP LEFT OF OBJECT
	MOVE	@WORLDTL,A1,L
	SUBXY	A1,A4			;SUBTRACT OUT WORLD BASE
	MOVE	*A8(OSIZE),A1,L
	ADDXY	A4,A1			;GET LOWER RT OF OBJECT

	CMPXY	A2,A1			;COMPARE UL TO LR
	JRYLT	QBOUT			;BR = DEFINITELY OUT
	JRXLT	QBOUT			;BR = IT'S OUT OF HERE
QBOUTLR:
	CMPXY	A3,A4
	JRYGT	QBOUT			;BR = DEFINITELY OUT
	JRXLT	QBNOUT			;BR = IT'S NOT OUT OF THIS BOX
QBOUT:
	CLRZ
	JRUC	QBOXOUTX
QBNOUT:
	SETZ
QBOXOUTX:
	MMFM	SP,A1,A2,A3,A4
	RETS

**************************************************************************
*                                                                        *
* QBOXIN - CHECK IF OBJECT IS COMPLETELY INSIDE OF BOX.			 *
* A2 = BOX TOP LEFT [Y,X]						 *
* A3 = BOX BOTTOM RIGHT [Y,X]						 *
* A8 = PTR TO OBJECT							 *
* RETURNS:								 *
* 	Z = TOTALLY OR PARTIALLY OUTSIDE BOX				 *
* 	NZ = COMPLETELY INSIDE OF BOX					 *
* NOTE: TRASHES A14							 *
*                                                                        *
**************************************************************************
QBOXIN:
	MMTM	SP,A1,A2,A3,A4
	MOVE	*A8(OYPOS),A4,W
	MOVE	*A8(OXPOS),A1,W
	SLL	16,A4
	MOVX	A1,A4	       		;GET TOP LEFT OF OBJECT
	MOVE	@WORLDTL,A1,L
	SUBXY	A1,A4			;SUBTRACT OUT WORLD BASE
	MOVE	*A8(OSIZE),A1,L
	ADDXY	A4,A1			;GET LOWER RT OF OBJECT

	CMPXY	A2,A4			;COMPARE UL TO UL
	JRYLT	QBNIN			;BR = DEFINITELY OUT
	JRXLT	QBNIN			;BR = IT'S OUT OF HERE
QBINLR:
	CMPXY	A3,A1
	JRYGT	QBNIN			;BR = DEFINITELY OUT
	JRXGT	QBNIN			;BR = IT'S NOT OUT OF THIS BOX
QBIN:
	CLRZ
	JRUC	QBOXINX
QBNIN:
	SETZ
QBOXINX:
	MMFM	SP,A1,A2,A3,A4
	RETS

*COMMENT IN IF YOU WANT TO MARK ANY OF THE MOVES
*GNP 4/13/90
	.IF	0
**************************************************************************
*								         *
* MARKMOVE - MARK THE ENTIRE MOVE MAP					 *
*								         *
**************************************************************************
MARKMOVE:
	MMTM	SP,A1,A2,A3
	MOVI	MOVEMAP,A1
	MOVE	@MOVECNT,A2,W
	MOVI	MOVESIZE,A3
	CALLR	MARK_MOVES
	MMFM	SP,A1,A2,A3
	RETS

**************************************************************************
*								         *
* MARKCMOVE - MARK THE AUXILARY MOVE MAP				 *
*								         *
**************************************************************************
MARKCMOVE:
	MMTM	SP,A1,A2,A3
	MOVI	CMOVEMAP,A1
	MOVE	@CMOVECNT,A2,W
	MOVI	CMOVESIZE,A3
	CALLR	MARK_MOVES
	MMFM	SP,A1,A2,A3
	RETS

**************************************************************************
*								         *
* MARKAMOVE - MARK THE AUXILARY MOVE MAP				 *
*								         *
**************************************************************************
MARKAMOVE:
	MMTM	SP,A1,A2,A3
	MOVI	AMOVEMAP,A1
	MOVE	@AMOVECNT,A2,W
	MOVI	AMOVESIZE,A3
	CALLR	MARK_MOVES
	MMFM	SP,A1,A2,A3
	RETS

**************************************************************************
*								         *
* MARKEMOVE - MARK THE EXIT MOVE MAP					 *
*								         *
**************************************************************************
MARKEMOVE:
	MMTM	SP,A1,A2,A3
	MOVI	EMOVEMAP,A1
	MOVE	@EMOVECNT,A2,W
	MOVI	EMOVESIZE,A3
	CALLR	MARK_MOVES
	MMFM	SP,A1,A2,A3
	RETS

**************************************************************************
*								         *
* MARK_MOVES - MARK ALL OF THE MOVES OF A GIVEN MAP			 *
* A1 = MAP								 *
* A2 = NUMBER OF MOVES							 *
* A3 = SIZE OF MOVE ELEMENT						 *
* NOTE: TRASHES A14							 *
*								         *
**************************************************************************
MARK_MOVES:
	MMTM	SP,A0,A8
MARK_MOVES_LP:
	MOVE	A2,A2
	JRZ	MARK_MOVES_X
	MOVI	MOVEMARKINIT,A14
	CALLA	GPALOBJSTF		;DO THE OBJECT
	JRZ	MARK_MOVES_X
	MOVE	A0,A8
	MOVE	A1,A0
	CALLR	TOMOVE
	MOVI	0202H,A0
	MOVE	A0,*A8(OCONST),W
	CALLA	INSERT_OBJ
	ADD	A3,A1
	DEC	A2
	JRUC	MARK_MOVES_LP
MARK_MOVES_X
	MMFM	SP,A0,A8
	RETS

MOVEMARKINIT:
	.LONG	0,0
	.WORD	0,0FF0H
	.LONG	MOVEMARK,0,DUMCOLL
	.WORD	DMACAL,JUNKOID

MOVEMARK:
	.word	4,4,1,1
	.long	>2000000,FIXED3

	.ENDIF

	.END
